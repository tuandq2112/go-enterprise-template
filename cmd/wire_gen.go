// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package cmd

import (
	"time"

	"go-clean-ddd-es-template/internal/application/commands"
	"go-clean-ddd-es-template/internal/application/queries"
	"go-clean-ddd-es-template/internal/application/services"
	repositories2 "go-clean-ddd-es-template/internal/domain/repositories"
	"go-clean-ddd-es-template/internal/infrastructure/config"
	"go-clean-ddd-es-template/internal/infrastructure/consumers"
	"go-clean-ddd-es-template/internal/infrastructure/database"
	"go-clean-ddd-es-template/internal/infrastructure/grpc"
	"go-clean-ddd-es-template/internal/infrastructure/messagebroker"
	"go-clean-ddd-es-template/internal/infrastructure/repositories"
	"go-clean-ddd-es-template/pkg/auth"
	"go-clean-ddd-es-template/pkg/i18n"
	"go-clean-ddd-es-template/pkg/logger"
	"go-clean-ddd-es-template/pkg/middleware"
	"go-clean-ddd-es-template/pkg/tracing"
)

// Injectors from wire.go:

// InitializeGRPCServer initializes gRPC server with all dependencies
func InitializeGRPCServer() (*grpc.GRPCServer, error) {
	databaseFactory := provideDatabaseFactory()
	config := provideConfig()
	writeDatabase, err := provideWriteDatabase(databaseFactory, config)
	if err != nil {
		return nil, err
	}
	readDatabase, err := provideReadDatabase(databaseFactory, config)
	if err != nil {
		return nil, err
	}
	eventDatabase, err := provideEventDatabase(databaseFactory, config)
	if err != nil {
		return nil, err
	}
	repositoryFactory := provideRepositoryFactory(writeDatabase, readDatabase, eventDatabase, config)
	userWriteRepository, err := provideUserWriteRepository(repositoryFactory)
	if err != nil {
		return nil, err
	}
	eventStore, err := provideEventStore(repositoryFactory)
	if err != nil {
		return nil, err
	}
	messageBrokerFactory := provideMessageBrokerFactory()
	messageBroker, err := provideMessageBroker(messageBrokerFactory, config)
	if err != nil {
		return nil, err
	}
	eventPublisher := provideEventPublisher(messageBroker, config)
	userCreateCommandHandler := provideUserCreateCommandHandler(userWriteRepository, eventStore, eventPublisher)
	userUpdateCommandHandler := provideUserUpdateCommandHandler(userWriteRepository, eventStore, eventPublisher)
	userDeleteCommandHandler := provideUserDeleteCommandHandler(userWriteRepository, eventStore, eventPublisher)
	userReadRepository, err := provideUserReadRepository(repositoryFactory)
	if err != nil {
		return nil, err
	}
	userGetQueryHandler := provideUserGetQueryHandler(userReadRepository)
	userListQueryHandler := provideUserListQueryHandler(userReadRepository)
	userGetByEmailQueryHandler := provideUserGetByEmailQueryHandler(userReadRepository)
	userEventsQueryHandler := provideUserEventsQueryHandler(userReadRepository)
	userService := provideUserService(userCreateCommandHandler, userUpdateCommandHandler, userDeleteCommandHandler, userGetQueryHandler, userListQueryHandler, userGetByEmailQueryHandler, userEventsQueryHandler)
	userRepository := provideUserRepository(userWriteRepository, userReadRepository)
	passwordService := providePasswordService()
	jwtService, err := provideJWTService(config)
	if err != nil {
		return nil, err
	}
	authRegisterCommandHandler := provideAuthRegisterCommandHandler(userRepository, eventStore, eventPublisher, passwordService, jwtService)
	authLoginCommandHandler := provideAuthLoginCommandHandler(userRepository, passwordService, jwtService)
	authService := provideAuthService(authRegisterCommandHandler, authLoginCommandHandler, jwtService)
	tracer, err := provideTracer(config)
	if err != nil {
		return nil, err
	}
	logger, err := provideLogger(config)
	if err != nil {
		return nil, err
	}
	grpcServer := provideGRPCServer(userService, authService, tracer, logger)
	return grpcServer, nil
}

// InitializeEventConsumer initializes event consumer with all dependencies
func InitializeEventConsumer() (*consumers.EventConsumerWrapper, error) {
	messageBrokerFactory := provideMessageBrokerFactory()
	config := provideConfig()
	messageBroker, err := provideMessageBroker(messageBrokerFactory, config)
	if err != nil {
		return nil, err
	}
	databaseFactory := provideDatabaseFactory()
	writeDatabase, err := provideWriteDatabase(databaseFactory, config)
	if err != nil {
		return nil, err
	}
	readDatabase, err := provideReadDatabase(databaseFactory, config)
	if err != nil {
		return nil, err
	}
	eventDatabase, err := provideEventDatabase(databaseFactory, config)
	if err != nil {
		return nil, err
	}
	repositoryFactory := provideRepositoryFactory(writeDatabase, readDatabase, eventDatabase, config)
	userReadRepository, err := provideUserReadRepository(repositoryFactory)
	if err != nil {
		return nil, err
	}
	userEventHandler := provideUserEventHandler(userReadRepository)
	productEventHandler := provideProductEventHandler()
	eventConsumer := provideEventConsumer(messageBroker, userEventHandler, productEventHandler, config)
	return eventConsumer, nil
}

// wire.go:

// Type aliases to distinguish between different database types
type (
	WriteDatabase database.Database
	ReadDatabase  database.Database
	EventDatabase database.Database
)

// provideConfig provides application configuration
func provideConfig() *config.Config {
	return config.Load()
}

// provideTracer provides tracing service
func provideTracer(cfg *config.Config) (*tracing.Tracer, error) {
	if !cfg.Tracing.Enabled {
		return nil, nil
	}
	return tracing.NewTracer(cfg.Tracing.ServiceName, "1.0.0", cfg.Tracing.Endpoint)
}

// provideLogger provides logger service
func provideLogger(cfg *config.Config) (logger.Logger, error) {
	return logger.NewLoggerFromConfig(cfg.Log.Level, cfg.Log.Format)
}

// provideTranslator provides i18n translator
func provideTranslator(cfg *config.Config) (*i18n.Translator, error) {
	translator := i18n.NewTranslator(cfg.I18n.DefaultLocale)

	if err := translator.LoadTranslations(cfg.I18n.TranslationsDir); err != nil {
		return nil, err
	}
	i18n.SetGlobalTranslator(translator)

	return translator, nil
}

// provideErrorHandler provides error handler with i18n support
func provideErrorHandler(translator *i18n.Translator, logger2 logger.Logger) *middleware.ErrorHandler {
	return middleware.NewErrorHandler(translator, logger2)
}

// provideDatabaseFactory provides database factory
func provideDatabaseFactory() *database.DatabaseFactory {
	return database.NewDatabaseFactory()
}

// provideWriteDatabase provides write database connection
func provideWriteDatabase(factory *database.DatabaseFactory, cfg *config.Config) (WriteDatabase, error) {
	db, err := factory.CreateDatabase(&cfg.WriteDatabase)
	return WriteDatabase(db), err
}

// provideReadDatabase provides read database connection
func provideReadDatabase(factory *database.DatabaseFactory, cfg *config.Config) (ReadDatabase, error) {
	db, err := factory.CreateDatabase(&cfg.ReadDatabase)
	return ReadDatabase(db), err
}

// provideEventDatabase provides event database connection
func provideEventDatabase(factory *database.DatabaseFactory, cfg *config.Config) (EventDatabase, error) {
	db, err := factory.CreateDatabase(&cfg.EventDatabase)
	return EventDatabase(db), err
}

// provideRepositoryFactory provides repository factory
func provideRepositoryFactory(
	writeDB WriteDatabase,
	readDB ReadDatabase,
	eventDB EventDatabase,
	cfg *config.Config,
) *repositories.RepositoryFactory {
	return repositories.NewRepositoryFactory(database.Database(writeDB), database.Database(readDB), database.Database(eventDB), cfg)
}

// provideMessageBrokerFactory provides message broker factory
func provideMessageBrokerFactory() *messagebroker.MessageBrokerFactory {
	return messagebroker.NewMessageBrokerFactory()
}

// provideMessageBroker provides message broker using factory
func provideMessageBroker(factory *messagebroker.MessageBrokerFactory, cfg *config.Config) (messagebroker.MessageBroker, error) {
	return factory.CreateMessageBroker(&cfg.MessageBroker)
}

// provideUserEventHandler provides user event handler
func provideUserEventHandler(readRepository repositories2.UserReadRepository) *consumers.UserEventHandler {
	return consumers.NewUserEventHandler(readRepository)
}

// provideProductEventHandler provides product event handler
func provideProductEventHandler() *consumers.ProductEventHandler {
	return consumers.NewProductEventHandler()
}

// provideEventConsumer provides generic event consumer with multiple handlers
func provideEventConsumer(
	broker messagebroker.MessageBroker,
	userEventHandler *consumers.UserEventHandler,
	productEventHandler *consumers.ProductEventHandler,
	cfg *config.Config,
) *consumers.EventConsumerWrapper {
	consumer := broker.GetConsumer()

	topicSet := make(map[string]bool)
	for _, topic := range cfg.MessageBroker.Topics {
		topicSet[topic] = true
	}

	// Convert to slice
	var topics []string
	for topic := range topicSet {
		topics = append(topics, topic)
	}

	fallbackTopics := []string{"product.created", "product.updated", "product.deleted"}
	for _, topic := range fallbackTopics {
		if !topicSet[topic] {
			topics = append(topics, topic)
		}
	}

	eventConsumer := consumers.NewEventConsumerWrapper(consumer, cfg.MessageBroker.GroupID, topics)

	eventConsumer.RegisterEventHandler("user.created", userEventHandler)
	eventConsumer.RegisterEventHandler("user.updated", userEventHandler)
	eventConsumer.RegisterEventHandler("user.deleted", userEventHandler)

	eventConsumer.RegisterEventHandler("product.created", productEventHandler)
	eventConsumer.RegisterEventHandler("product.updated", productEventHandler)
	eventConsumer.RegisterEventHandler("product.deleted", productEventHandler)

	return eventConsumer
}

// provideUserWriteRepository provides user write repository
func provideUserWriteRepository(factory *repositories.RepositoryFactory) (repositories2.UserWriteRepository, error) {
	return factory.CreateUserWriteRepository()
}

// provideUserReadRepository provides user read repository
func provideUserReadRepository(factory *repositories.RepositoryFactory) (repositories2.UserReadRepository, error) {
	return factory.CreateUserReadRepository()
}

// provideUserRepository provides user repository (combines write and read)
func provideUserRepository(writeRepo repositories2.UserWriteRepository, readRepo repositories2.UserReadRepository) repositories2.UserRepository {
	return writeRepo.(repositories2.UserRepository)
}

// provideEventStore provides event store
func provideEventStore(factory *repositories.RepositoryFactory) (repositories2.EventStore, error) {
	return factory.CreateEventStore()
}

// provideEventPublisher provides event publisher
func provideEventPublisher(broker messagebroker.MessageBroker, cfg *config.Config) repositories2.EventPublisher {
	return repositories.NewMessageBrokerEventPublisher(broker, cfg)
}

// Command Handlers (Write Operations)
func provideUserCreateCommandHandler(
	userWriteRepo repositories2.UserWriteRepository,
	eventStore repositories2.EventStore,
	eventPublisher repositories2.EventPublisher,
) *commands.UserCreateCommandHandler {
	return commands.NewUserCreateCommandHandler(userWriteRepo, eventStore, eventPublisher)
}

func provideUserUpdateCommandHandler(
	userWriteRepo repositories2.UserWriteRepository,
	eventStore repositories2.EventStore,
	eventPublisher repositories2.EventPublisher,
) *commands.UserUpdateCommandHandler {
	return commands.NewUserUpdateCommandHandler(userWriteRepo, eventStore, eventPublisher)
}

func provideUserDeleteCommandHandler(
	userWriteRepo repositories2.UserWriteRepository,
	eventStore repositories2.EventStore,
	eventPublisher repositories2.EventPublisher,
) *commands.UserDeleteCommandHandler {
	return commands.NewUserDeleteCommandHandler(userWriteRepo, eventStore, eventPublisher)
}

// Query Handlers (Read Operations)
func provideUserGetQueryHandler(userReadRepository repositories2.UserReadRepository) *queries.UserGetQueryHandler {
	return queries.NewUserGetQueryHandler(userReadRepository)
}

func provideUserListQueryHandler(userReadRepository repositories2.UserReadRepository) *queries.UserListQueryHandler {
	return queries.NewUserListQueryHandler(userReadRepository)
}

func provideUserGetByEmailQueryHandler(userReadRepository repositories2.UserReadRepository) *queries.UserGetByEmailQueryHandler {
	return queries.NewUserGetByEmailQueryHandler(userReadRepository)
}

func provideUserEventsQueryHandler(userReadRepository repositories2.UserReadRepository) *queries.UserEventsQueryHandler {
	return queries.NewUserEventsQueryHandler(userReadRepository)
}

// provideUserService provides user service
func provideUserService(
	createCommandHandler *commands.UserCreateCommandHandler,
	updateCommandHandler *commands.UserUpdateCommandHandler,
	deleteCommandHandler *commands.UserDeleteCommandHandler,
	getQueryHandler *queries.UserGetQueryHandler,
	listQueryHandler *queries.UserListQueryHandler,
	getByEmailQueryHandler *queries.UserGetByEmailQueryHandler,
	eventsQueryHandler *queries.UserEventsQueryHandler,
) *services.UserService {
	return services.NewUserService(
		createCommandHandler,
		updateCommandHandler,
		deleteCommandHandler,
		getQueryHandler,
		listQueryHandler,
		getByEmailQueryHandler,
		eventsQueryHandler,
	)
}

// provideJWTService provides JWT service
func provideJWTService(cfg *config.Config) (*auth.JWTService, error) {
	return auth.NewJWTService(cfg.Auth.PrivateKeyPath, cfg.Auth.PublicKeyPath, time.Duration(cfg.Auth.TokenExpiry)*time.Hour)
}

// providePasswordService provides password service
func providePasswordService() *auth.PasswordService {
	return auth.NewPasswordService(12)
}

// provideAuthRegisterCommandHandler provides auth register command handler
func provideAuthRegisterCommandHandler(
	userRepo repositories2.UserRepository,
	eventStore repositories2.EventStore,
	eventPublisher repositories2.EventPublisher,
	passwordService *auth.PasswordService,
	jwtService *auth.JWTService,
) *commands.AuthRegisterCommandHandler {
	return commands.NewAuthRegisterCommandHandler(userRepo, eventStore, eventPublisher, passwordService, jwtService)
}

// provideAuthLoginCommandHandler provides auth login command handler
func provideAuthLoginCommandHandler(
	userRepo repositories2.UserRepository,
	passwordService *auth.PasswordService,
	jwtService *auth.JWTService,
) *commands.AuthLoginCommandHandler {
	return commands.NewAuthLoginCommandHandler(userRepo, passwordService, jwtService)
}

// provideAuthService provides auth service
func provideAuthService(
	registerHandler *commands.AuthRegisterCommandHandler,
	loginHandler *commands.AuthLoginCommandHandler,
	jwtService *auth.JWTService,
) *services.AuthService {
	return services.NewAuthService(registerHandler, loginHandler, jwtService)
}

// provideGRPCServer provides gRPC server
func provideGRPCServer(
	userService *services.UserService,
	authService *services.AuthService,
	tracer *tracing.Tracer, logger2 logger.Logger,
) *grpc.GRPCServer {
	return grpc.NewGRPCServer(userService, authService, tracer, logger2)
}
